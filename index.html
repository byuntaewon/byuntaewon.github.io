<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 다중 로더 뷰어</title>
    <style>
        body { margin: 0; }
        canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh;
        }
        /* 파일 선택 버튼을 화면 상단에 고정 */
        #file-input {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border-radius: 8px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <input type="file" id="file-input" />

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // (핵심) 지원할 모든 로더들을 import 합니다.
        import { USDZLoader } from 'three/addons/loaders/USDZLoader.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        // --- 1. 기본 씬(Scene) 설정 ---
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333); // 어두운 배경

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 5); // 카메라 위치 조정

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 조명 추가
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);
        
        // 마우스 컨트롤
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // 창 크기 조절 대응
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 2. 로더 관리 및 파일 처리 ---

        // 로더 인스턴스 생성
        const usdzLoader = new USDZLoader();
        const gltfLoader = new GLTFLoader();
        const objLoader = new OBJLoader();
        const fbxLoader = new FBXLoader();
        
        let currentModel = null; // 현재 씬에 추가된 모델을 추적

        // 파일 입력(input)에 이벤트 리스너 추가
        document.getElementById('file-input').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            // 파일 확장자 추출 (소문자로)
            const fileName = file.name;
            const fileExt = fileName.slice(fileName.lastIndexOf('.')).toLowerCase();

            // 이전 모델이 있다면 씬에서 제거
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }

            // 파일 데이터를 읽기 위한 URL 생성
            const fileURL = URL.createObjectURL(file);
            let loader = null;

            // (핵심) 확장자에 따라 적절한 로더 선택
            switch (fileExt) {
                case '.usdz':
                case '.usda': // .usda도 USDZLoader가 처리
                    loader = usdzLoader;
                    break;
                case '.glb':
                case '.gltf':
                    loader = gltfLoader;
                    break;
                case '.obj':
                    loader = objLoader;
                    break;
                case '.fbx':
                    loader = fbxLoader;
                    break;
                default:
                    alert(`지원하지 않는 파일 형식입니다: ${fileExt}`);
                    return;
            }

            // 선택된 로더로 파일 로드 실행
            loader.load(
                fileURL,
                // 로드 성공 시
                (model) => {
                    // GLTF/GLB는 .scene을, 나머지는 모델 자체를 추가
                    if (fileExt === '.glb' || fileExt === '.gltf') {
                        currentModel = model.scene;
                    } else {
                        currentModel = model;
                    }
                    scene.add(currentModel);
                    console.log(`${fileName} 로드 성공!`);
                    
                    // (선택사항) 모델 크기에 맞춰 카메라 자동 조절
                    fitCameraToModel(currentModel);
                },
                // 로드 진행 중 (콘솔에만 표시)
                (xhr) => {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                // 로드 실패 시
                (error) => {
                    console.error('모델 로드 중 에러 발생', error);
                    alert('모델을 로드하는 중 오류가 발생했습니다. 콘솔을 확인하세요.');
                }
            );
        });

        // (선택사항) 모델을 씬 중앙에 맞추고 카메라 거리를 조절하는 함수
        function fitCameraToModel(model) {
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            // 모델의 크기(bounding box)에 따라 카메라 거리 조절
            const maxSize = Math.max(size.x, size.y, size.z);
            const fitHeightDistance = maxSize / (2 * Math.atan(Math.PI * camera.fov / 360));
            const fitWidthDistance = fitHeightDistance / camera.aspect;
            const distance = 1.2 * Math.max(fitHeightDistance, fitWidthDistance);

            controls.target.copy(center); // 컨트롤이 모델의 중앙을 바라보게
            
            camera.position.copy(center);
            camera.position.z += distance; // Z축으로 거리만큼 이동 (정면에서)
            camera.position.y += distance * 0.5; // 약간 위에서
            
            camera.lookAt(center);
            controls.update();
        }

    </script>
</body>
</html>
